# BIRD v2 Configuration for AEGIS Edge Node
# BGP Anycast Routing Daemon
#
# This configuration announces the AEGIS anycast prefix to upstream peers
# and handles route filtering, RPKI validation, and failover

# Router ID (must be unique for each edge node)
# Override this with the node's primary IP
router id 10.0.0.1;

# Enable debug logging
log syslog all;
debug protocols { states, routes, filters, interfaces, events };

# Define constants
define AEGIS_ANYCAST_V4 = 203.0.113.0/24;  # Example anycast prefix (replace with actual)
define AEGIS_ANYCAST_V6 = 2001:db8::/32;   # Example anycast prefix (replace with actual)
define AEGIS_AS = 64512;                    # AEGIS AS number (replace with actual)

# ============================================================================
# RPKI Configuration (Route Origin Validation)
# ============================================================================

# Connect to Routinator for RPKI validation
roa4 table rpki4;
roa6 table rpki6;

protocol rpki rpki_validator {
    roa4 { table rpki4; };
    roa6 { table rpki6; };

    # Connect to local Routinator instance via RTR protocol
    remote "127.0.0.1" port 3323;

    # Retry configuration
    retry keep 90;
    refresh keep 900;
    expire keep 172800;
}

# ============================================================================
# Routing Tables
# ============================================================================

# IPv4 routing table
ipv4 table master4;

# IPv6 routing table
ipv6 table master6;

# ============================================================================
# Kernel Protocol (sync with OS routing table)
# ============================================================================

protocol kernel kernel4 {
    ipv4 {
        import none;   # Don't import routes from kernel
        export all;    # Export all BGP routes to kernel
    };
    merge paths on;    # Enable multipath routing
}

protocol kernel kernel6 {
    ipv6 {
        import none;
        export all;
    };
    merge paths on;
}

# ============================================================================
# Device Protocol (monitor network interfaces)
# ============================================================================

protocol device {
    scan time 10;  # Scan for interface changes every 10 seconds
}

# ============================================================================
# Direct Protocol (directly connected routes)
# ============================================================================

protocol direct {
    ipv4;
    ipv6;
    interface "lo";  # Monitor loopback for anycast IP
}

# ============================================================================
# Static Routes (Anycast Announcement)
# ============================================================================

protocol static static4 {
    ipv4;

    # Announce anycast prefix (only if local service is healthy)
    # This route will be announced via BGP to all peers
    route AEGIS_ANYCAST_V4 blackhole;
}

protocol static static6 {
    ipv6;
    route AEGIS_ANYCAST_V6 blackhole;
}

# ============================================================================
# Filter Functions
# ============================================================================

# Filter for RPKI validation
function rpki_validate_v4(int asn) {
    if (roa_check(rpki4, net, asn) = ROA_INVALID) then {
        print "ROA INVALID: ", net, " AS", asn;
        return false;
    }
    return true;
}

function rpki_validate_v6(int asn) {
    if (roa_check(rpki6, net, asn) = ROA_INVALID) then {
        print "ROA INVALID: ", net, " AS", asn;
        return false;
    }
    return true;
}

# Import filter: Accept routes from peers with RPKI validation
filter bgp_import_v4 {
    # Reject bogon prefixes
    if net ~ [
        0.0.0.0/8+,          # RFC 1122: This network
        10.0.0.0/8+,         # RFC 1918: Private-use
        100.64.0.0/10+,      # RFC 6598: Shared address space
        127.0.0.0/8+,        # RFC 1122: Loopback
        169.254.0.0/16+,     # RFC 3927: Link-local
        172.16.0.0/12+,      # RFC 1918: Private-use
        192.0.0.0/24+,       # RFC 6890: IETF Protocol Assignments
        192.0.2.0/24+,       # RFC 5737: Documentation (TEST-NET-1)
        192.168.0.0/16+,     # RFC 1918: Private-use
        198.18.0.0/15+,      # RFC 2544: Benchmarking
        198.51.100.0/24+,    # RFC 5737: Documentation (TEST-NET-2)
        203.0.113.0/24+,     # RFC 5737: Documentation (TEST-NET-3)
        224.0.0.0/4+,        # RFC 5771: Multicast
        240.0.0.0/4+         # RFC 6890: Reserved
    ] then {
        print "Rejected bogon prefix: ", net;
        reject;
    }

    # Validate route origin with RPKI
    if !rpki_validate_v4(bgp_path.last) then {
        reject;
    }

    # Reject routes with private AS numbers in path
    if bgp_path ~ [64512..65534, 4200000000..4294967294] then {
        print "Rejected route with private ASN: ", net;
        reject;
    }

    # Accept valid routes
    accept;
}

filter bgp_import_v6 {
    # Reject bogon IPv6 prefixes
    if net ~ [
        ::/0,                # Default route
        ::/128,              # Unspecified
        ::1/128,             # Loopback
        ::ffff:0.0.0.0/96,   # IPv4-mapped
        fe80::/10,           # Link-local
        fc00::/7,            # Unique local addresses
        ff00::/8             # Multicast
    ] then {
        print "Rejected bogon IPv6 prefix: ", net;
        reject;
    }

    # RPKI validation
    if !rpki_validate_v6(bgp_path.last) then {
        reject;
    }

    accept;
}

# Export filter: Announce only AEGIS anycast prefix
filter bgp_export_v4 {
    # Only announce our anycast prefix
    if net = AEGIS_ANYCAST_V4 then {
        # Add BGP communities for route policy
        bgp_community.add((AEGIS_AS, 1));  # AEGIS edge node
        accept;
    }
    reject;
}

filter bgp_export_v6 {
    if net = AEGIS_ANYCAST_V6 then {
        bgp_community.add((AEGIS_AS, 1));
        accept;
    }
    reject;
}

# ============================================================================
# BGP Protocol Template
# ============================================================================

template bgp bgp_peer {
    local as AEGIS_AS;
    graceful restart on;

    # BGP timers
    hold time 90;
    keepalive time 30;
    connect retry time 30;

    # Path attributes
    next hop self;

    # Error handling
    error wait time 60, 300;
    error forget time 300;

    # Route limits (prevent route leak attacks)
    receive limit 10000 action restart;

    ipv4 {
        import filter bgp_import_v4;
        export filter bgp_export_v4;
    };

    ipv6 {
        import filter bgp_import_v6;
        export filter bgp_export_v6;
    };
}

# ============================================================================
# BGP Peers (examples - replace with actual peers)
# ============================================================================

# Example: Transit Provider
protocol bgp transit1 from bgp_peer {
    description "Transit Provider 1";
    neighbor 192.0.2.1 as 65001;
    multihop 2;
    password "SecurePassword123";  # Use strong authentication
}

# Example: Internet Exchange Point (IXP)
protocol bgp ixp1 from bgp_peer {
    description "Example IXP Route Server";
    neighbor 198.51.100.1 as 65002;
    rs client;  # This is a route server
}

# Example: Private Peering
protocol bgp peer1 from bgp_peer {
    description "Private Peer 1";
    neighbor 203.0.113.1 as 65003;
}

# ============================================================================
# BFD (Bidirectional Forwarding Detection) for fast failover
# ============================================================================

protocol bfd {
    interface "*" {
        min rx interval 100 ms;
        min tx interval 100 ms;
        idle tx interval 300 ms;
        multiplier 3;
    };
}

# ============================================================================
# Health Check Integration
# ============================================================================

# This section would integrate with external health checks
# If the local AEGIS service is unhealthy, withdraw the anycast route
# Implementation requires custom scripts that update BIRD via birdc

# Example:
# protocol static health_check {
#     ipv4;
#     # Route is added/removed by health check script via birdc
# }
